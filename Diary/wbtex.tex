In this section we aim to use what we can see from the functions themselves to satisfy some coverage
criteria. To evaluate coverage we will use the coverage.py package. This can evaluate both statement and branch coverage and enumerate which statements or branches were not executed.

As our function contains a loop we want to include loop coverage. 

The function we have chosen to white box test is the multi\_dot() function and it's subsidiary functions \_multi\_dot() and multi\_dot\_three().

This function performs the dot product of an array of arrays. It consists of several if/ else statements a recursive loop and several different return options. In our testing we want to ensure that all statments and branches are covered along with coverage of the loops. 



\paragraph{Node Coverage}


For node coverage we have the critereon that our tests cause all statements in the program to be executed. Thus we want to ensure that in our set of tests that all nodes are visited on at least one test path. Figure 1 shows the control flow graph for the functions under test. 



\paragraph{Edge Coverage}

For edge coverage we have the critereon that our tests cause all branches to execute. In this case we have the set of edges \\
\{(1,2),(1,3),(1,4),(4,5),(4,6),(5,6),(6,7),(6,8),(8,9),(8,10),(8,12),(12,10),(10,16),(9,11),(11,13)\\
,(13,14),(13,15),(15,16),(16,17),(16,18),(16,19)\}.
Our test requirements are that every edge is contained in at least one of our test paths.
\\

\paragraph{Loop Coverage}

A loop is covered if in at least one test executed the loop 0 times, if in some test the loop was executed exactly once, and if in some test the body was executed more than once. In the case of this code we can't test it only once so we execute it a minimum number of times i.e. with four arrays.
\begin{itemize}
\item Zero times - Test 1 - The \_multi\_dot function is not called.  
\item Minimum - Test 5.
\item Many times - test 7 - The loop recurses many times
\end{itemize}


To achieve coverage for these cases we create a set of test paths that include all nodes and edges given above along with paths that execute the loop zero times, the minimum amount of times and many times. 

\begin{enumerate}
\item \{1,2\}  
\item \{(1,3)\}
\item \{1,4,5,6,8,9,11,13,14,16,17\}
\item \{1,4,6,7,8,9,11,13,15,16,18\}
\item \{1,4,5,6,7,8,10,12,10,16,17\}
\item \{1,4,6,8,9,11,13,14,16,19\}
\item \{1,4,5,6,7,8,10,12,10,12,10,16,17\}
\end{enumerate}



\paragraph{Test 1: Arguments$<$2}


The test test\_multi\_dot\_raises was created to execute path 1. It returns a raises value error.


\paragraph{Test 2: Arguments=2}

To execute path 2 the test test\_multi\_two was created.This path calls the dot fonction and then returns. It returns the dot product of the two.


\paragraph{Test 3: Arguments=3,dimension of 1st argument = 1}

The test test\_multi\_ndim\_10 was executes the test path 3. By setting the dimesion of the first argument to be 1 we execute the branches 5 and 17.




\paragraph{Test 4: Arguments=3,dimension of last argument = 1}

For this case the test test\_multi\_ndim\_01 was created. See Appendix for test specifics.

This test gives us node coverage for \{1,4,6,7,8,9,11,13,15,16,18\} and branch coverage for \{(1,4),

(4,6),(6,7),(7,8),(8,9),(9,11),(11,13),(13,14),(14,16),(16,18)\}.



\paragraph{Test 5: Arguments$>$3,dimension of first and last argument = 1}

For this case the test test\_multi\_ndim\_11 was created. See Appendix for test specifics.

This test gives us node coverage for \{1,4,5,6,7,8,10,12,10,16,17\} and fulfils the requirements that the edges {(8,10),(10,12),(12,10),(16,19)} are executed.


\paragraph{Test 6: Arguments=3,dimension of first and last argument $>$ 1}


For this case the test test\_multi\_ndim\_00 was created. See Appendix for test specifics.
This test gives us node coverage for \{1,4,6,8,9,11,13,14,16,19\} and fulfils the final requirement that the edge (16,19) is executed.


